---
title: "WebGL Photos - Notes"
series: "WebGL Photo filters & effects"
publishedOn: "2023-06-15T16:31:05.404Z"
tags: ["WebGL"]
published: false
---

In this series we're going to break down how to achieve common filters & effects for editing photos like you would find in Photoshop, Lightroom, VSCO or Instagram.

We'll start by looking at some basic color correction functions like brightness, contrast, exposure and saturation. Along with a basic intro to WebGL (Web Graphics Library) and GLSL (OpenGL Shading Language) shaders. I won't go deeply into the WebGL side here, but I'll leave some resources at the end of the article.

// NOTE add video of proper image editor 

### Basic WebGL concepts

WebGL is a JavaScript API for rendering high-performant interactive 3D and 2D graphics in the browser. It uses your system's GPU (Graphic Processing Unit) to compute your programs in parallel rather than the linear fashion of the CPU. Graphics cards are extremely fast and have many mathematical functions built in.

- **Shader**: a program that runs on the GPU, as apposed to the CPU
- **Fragment shader**: a program (on the GPU) that runs for every pixel in your image in parallel 
- **Uniform**: a variable that is the same for every fragment shader in a render pass
- **Texture**: an image we have passed into a fragment shader, it's stored as an 2x2 matrix of vec4 values. You can think of this as a color value for each pixel cell (row x column).

### GLSL colors
Colors in GLSL are a 4 value vector, containing the red, green, blue, alpha channels. These map to the rgba values you know in CSS, but are 0.0 to 1.0 instead of 0 to 255.

Black in CSS: `rgba(0, 0, 0, 255);` <br/>
Black in GLSL: `vec4(0.0, 0.0, 0.0, 1.0);` 

White in CSS: `rgba(255, 255, 255, 255);` <br/>
White in GLSL: `vec4(1.0, 1.0, 1.0, 1.0);`

## Our foundational shader

The foundations of our shader lie in a few inputs `uniform`s and one color value `output`. Let's have a quick look then I'll break it down.

```glsl
#version 300 es
precision highp float;

uniform vec2 u_resolution;
uniform sampler2D u_image;

out vec4 outColor;

void main() {
  vec2 uv = gl_FragCoord.xy/u_resolution;

  vec4 texel = texture(u_image, uv);
  outColor = texel; 
}
```

Starting from the top we have `#version 300 es`, this tells WebGL which version of GLSL our shader is written in. This is quite important as there are many breaking changes between version `100` and `300`. The `precision` value tells our program how what precision of floating points to use, this is how many digits the floating points have.

We pass our image in as a uniform `u_image`, which we can read with glsl's `texture` function. We also need the resolution (width and height) of our canvas to correctly map our image data to our canvas size, passing this into the `texture` function.

The `texture` function outputs a `texel`, a texture element rather than a pixel. We can then simple assign this to our `outColor` and we are done. 

This program doesn't do much at the moment. It simply outputs the image we pass in.

<WebGLFilters step="Intro" />

## Brightness

To increase the brightness of our image we'll want to increase our color value by adding the same amount to each `rgb` value.

```glsl
vec4 brightness(vec4 color) {
  // Update only rgb values
  vec3 rgb = color.rgb + value;
  return vec4(rgb, color.a);
}
```

<WebGLFilters step="Brightness" />

## Exposure

To update the exposure we want to multiply, instead of adding to each `rgb` value by the same amount. This changes the brightness of our image by it's current luminosity (the strength of the individual texel). As multiplying a zero value outputs another zero we need to increase our original value by 1.0.

```glsl
vec4 exposure(vec4 color) {
  // Update only rgb values
  vec3 rgb = (1.0 + color.rgb) * color;
  return vec4(rgb, color.a);
}
```

<WebGLFilters step="Exposure" />

## Contrast

This is the contrast between the highs and lows of your image. So to increase the contrast we need to increase the range between the higher and lower values. We increase values over 0.5, while decreasing values under 0.5.

```glsl
vec4 contrast(vec4 color, float value) {
  // Update only rgb values
  vec3 rgb = 0.5 + (1.0 + value) * (color.rgb - 0.5);
  return vec4(rgb, color.a);
}
```

<WebGLFilters step="Contrast" />

## Saturation

Saturation is the "colorfulness" of an image. The more saturated an image is the more colorful it appear, in contrast to a null, subded image. 

When we increase the saturation we increase the contrast between the `rgb` channels of a texel. Meaning a fully saturate texels would be one of 3 values `vec4(1, 0, 0, 1)` ,  `vec3(0, 1, 0, 1)`  or  `vec4(0, 0, 1, 1)`.

To create a desaturated (black and white or grayscale) image we can take the average of the channels.

```glsl
vec4 desaturated(vec4 color) {
  vec4 luminance = vec4(color.r + color.g + color.b / 3.0);
  return vec4(vec3(luminance), 1.0);
}
```

However the human eye doesn't perceive the luminosity of each color channel in the linear fashion as our WebGL value ranges. We need to adapt our rgb values by a factor that has been setout by the Web Content Accessibility Guidelines (WCAG) section on [relative luminance](https://www.w3.org/TR/WCAG21/#dfn-relative-luminance);


```glsl
vec4 desaturated(vec4 color) {
  // sRGB colorspace luminosity factor
  vec3 lumFactor = vec3(0.2126, 0.7152, 0.0722);
  vec3 rgb = vec3(dot(color, luminosityFactor));
  return vec4(rgb, color.a);
}

vec4 saturation(vec4 color, float value) {
  vec4 desaturated = desaturated(color);
  return mix(desaturated, color, 1.0 + value);
}
```

<WebGLFilters step="Saturation" />

### Together

<WebGLFilters step="Article1" />

In the next article we'll take a look at how to achieve some basic effects such as grain, pixelate and blur.
- WebGL & React state
- GLSL / Photo color correction
- GLSL / Photo Hue
- GLSL / Photo Grain
- GLSL / Photo Pixelation
- GLSL / Photo Vignette
- GLSL / Duotone

- Camera is already doing it behind the scenes
- ~Hue~

Effects:
- Grain
- Pixelation
- Vignette
- Blur
- Duotone

We can handle these in the browser with WebGL and glsl fragment shaders. I'm not going to go into the WebGL side of things here as it's too big for a single article. I've used raw WebGL for these experiment but these shaders would easily work with Three.js or another WebGL abstraction.

Since we are increasing the brightness by addition will eventually make every pixel white, Exposure uses multiplication so keeps the darks darker.

