---
title: "Chromatic Aberration"
series: "WebGL Image Processing"
issue: "10"
publishedOn: "2023-06-28T16:31:05.404Z"
tags: ["WebGL"]
thumb: "/article-webgl-chromatic-aberration.jpg"
published: true
---

<WebGLImageProcessingIntro />

### What is Chromatic Aberration?

Chromatic aberration, or color fringing, is an optical issue that occurs in a camera lens when it's unable to bring all wavelengths of color to the same focal plane.

We can simulate this effect by linearly moving one or more of our RGB channels from our texure along the x or y plane. Here are two examples of moving the red and blue channels:

<Dither step="chromatic-aberration-red" />

<Dither step="chromatic-aberration-blue" />

The glsl code for this is quite straight forward. Below we pass our texel data into our chromatic aberration function. This generates a vec4 color value based on the texel at our program's uv. We can then move our red channel by a `xOffset` and `yOffset`. 

```glsl
vec4 chromaticAberration(vec2 uv, vec4 fragColor) {
  return vec4(
    texture(
      u_image, 
      vec2(uv.x + (0.1 * xOffset), uv.y + (0.1 * yOffset))
    ).x,
    texture(
      u_image, 
      uv
    ).y,
    texture(
      u_image, 
      uv
    ).z,
    1.0
  );
}

void main() {
  // map uv between 0 -> 1
  vec2 uv = gl_FragCoord.xy/u_resolution;
  vec4 texel = texture(u_image, uv);
  outColor = chromaticAberration(uv, texel);
}
```

### Distance from edges

Instead of linearly moving each color channel we can increase the amount by the distance from the center, this mimics the effect seen in lenses. Similar to our vingette effect in the [previous article](/p/2023-07-webgl-09-vingette).

<Dither step="chromatic-aberration" />

In our GLSL code we get our uv's distance from the center with `length(uv - 0.5)` and we multiply this by an offset for each channel (this is controlled by the dials).

```glsl 
vec4 chromaticAberration(vec2 uv, vec4 fragColor) {
  float d = length(uv - 0.5);

  return vec4(
    texture(
      u_image, 
      uv - d * 0.1 * redOffset
    ).x,
    texture(
      u_image, 
      uv + d * 0.1 * blueOffset
    ).y,
    texture(
      u_image, 
      uv - d * 0.1 * greenOffset
    ).z,
    1.0
  );
}

void main() {
  // map uv between 0 -> 1
  vec2 uv = gl_FragCoord.xy/u_resolution;
  vec4 texel = texture(u_image, uv);
  outColor = chromaticAberration(uv, texel);
}
```
