---
title: "Threshold"
series: "WebGL Image Processing"
issue: "07"
publishedOn: "2023-06-28T16:31:05.404Z"
tags: ["WebGL"]
thumb: "/article-webgl-threshold.jpg"
published: true
---

We're going to look into the threshold effect. This article was massive inspired by the classic threshold/halftone article featuring [Lena](http://caca.zoy.org/study/index.html), however we'll look at this from a WebGL/GLSL viewpoint and will show code to obtain these effects. 

## What is Thresholding?

Thresholding is simplying segmenting our image's color values into a smaller range. It is a method of **color quantization** which was mainly developed for image compression (reducing the size of images) to meet the limitations of the technology available at that time. 

Computers started out with extremely limited color rendering options. 8-bit pixel depth was 256 colors, while 4-bit was only 16 colors. And too make it worse different machines had different color palettes! This needs an article of it's own.

Any image rendered on a system had to be rendered in those colors.

We don't have these issues anymore (image compression is still in use but not with as dramatic effects) but thresholding and dithering algorithms are still used for an asetihic look.

We'll use this image for the rest article, with an gradient bar on the side (thanks lena) to make it easier to precieve what is happening to the color range.

<Dither step="0-photos" />

## A basic example

For example instead of using the whole range of glsl's 0-1 floating point color channel we could round our values to either 0 or 1, if our color value is lower or higher than 0.5.

The results of this segmention depend on the threshold amount and the white balance of our image. For different images there will be a better threshold amount to pick. Try changing the threshold amount for the image below, see how the gradient on the side is clamped to either black or white at a specfic point.
 
<Dither step="1-threshold" />

Now this isn't the most specular image, in fact it looks pretty bad, but it's simple to understand and will lead us to more interesting effects. Let's break it down with GLSL.

We'll start with our trusty grayscale function we covered in [color corrrection article]().
```glsl
  // make image grayscale
  vec4 lum = vec4(0.2126, 0.7152, 0.0722, 0);
  float grayscale = dot(outColor, lum);
```

Now that we have a grayscale image can simplying take our 0-1 color channel value and round up or down depending on our threshold value (we've used 0.5 here).

```glsl
float thresholdValue = 0.5;

float threshold(float color) {
  if (color > thresholdValue) {
    return 1.0;
  }
  return 0.0;
}

outcolor = vec4(vec3(threshold(grayscale)), 1.0);
```

### Multi step Threshold

In our binary threshold we lose a lot of information from our image, and it make it hard to recongise what we are looking at. A simple improvement to this would be to add more information, instead of a binary 2 value (white, black) image we could use 3 values (white, grey, black).

We can set these threshold amounts to different values.

<Dither step="2-threshold-steps" />

We achieve this by simplying adding an additional condition statement to our threshold function.

```glsl
float thresholdWhiteValue = 0.5;
float thresholdGreyValue = 0.25;

float threshold(float color) {
  if (color > thresholdWhitealue) {
    return 1.0;
  }
  if (color > thresholdGreyValue) {
    return 0.5;
  }
  return 0.0;
}
```

### Threshold with noise

A simple way to improve our threshold is to add some randomness (noise) between our thresholded steps. 

<Dither step="3-threshold-noise" />

```glsl
float rand(vec2 uv) {
  return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453);
}

float grainMultiplier = 1.2;

void main() {
  // ... load image 
  float thresholded = threshold(
    grayscale + ((rand(uv) / 9.0) * grainMultiplier)
  );

  outColor = vec4(vec3(thresholded), 1.0);
}
```

Next we'll extend this effect to use [dithering/halftone patterns]() for each threshold step.
